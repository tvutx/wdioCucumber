{
  "script": "return (function isElementClickable(elem) {\r\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\r\n        return false;\r\n    }\r\n    // Edge before switching to Chromium\r\n    const isOldEdge = !!window.StyleMedia;\r\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\r\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\r\n    // get overlapping element\r\n    function getOverlappingElement(elem, context) {\r\n        context = context || document;\r\n        const elemDimension = elem.getBoundingClientRect();\r\n        const x = elemDimension.left + (elem.clientWidth / 2);\r\n        const y = elemDimension.top + (elem.clientHeight / 2);\r\n        return context.elementFromPoint(x, y);\r\n    }\r\n    // get overlapping element rects (currently only the first)\r\n    // applicable if element's text is multiline.\r\n    function getOverlappingRects(elem, context) {\r\n        context = context || document;\r\n        const elems = [];\r\n        const rects = elem.getClientRects();\r\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\r\n        const rect = rects[0];\r\n        const x = rect.left + (rect.width / 2);\r\n        const y = rect.top + (rect.height / 2);\r\n        elems.push(context.elementFromPoint(x, y));\r\n        return elems;\r\n    }\r\n    // get overlapping elements\r\n    function getOverlappingElements(elem, context) {\r\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\r\n    }\r\n    // is a node a descendant of a given node\r\n    function nodeContains(elem, otherNode) {\r\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\r\n        if (isOldEdge) {\r\n            let tmpElement = otherNode;\r\n            while (tmpElement) {\r\n                if (tmpElement === elem) {\r\n                    return true;\r\n                }\r\n                tmpElement = tmpElement.parentNode;\r\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\r\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\r\n                    tmpElement = tmpElement.host;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        return elem.contains(otherNode);\r\n    }\r\n    // is one of overlapping elements the `elem` or one of its child\r\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\r\n        if (elementsFromPoint.some(function (elementFromPoint) {\r\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\r\n        })) {\r\n            return true;\r\n        }\r\n        // shadow root\r\n        // filter unique elements with shadowRoot\r\n        // @ts-ignore\r\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\r\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\r\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\r\n        });\r\n        // getOverlappingElements of every element with shadowRoot\r\n        let shadowElementsFromPoint = [];\r\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\r\n            let shadowElement = elemsWithShadowRoot[i];\r\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\r\n        }\r\n        // remove duplicates and parents\r\n        // @ts-ignore\r\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\r\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\r\n            return !elementsFromPoint.includes(x);\r\n        });\r\n        if (shadowElementsFromPoint.length === 0) {\r\n            return false;\r\n        }\r\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\r\n    }\r\n    // copied from `isElementInViewport.js`\r\n    function isElementInViewport(elem) {\r\n        if (!elem.getBoundingClientRect) {\r\n            return false;\r\n        }\r\n        const rect = elem.getBoundingClientRect();\r\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\r\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\r\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\r\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\r\n        return (vertInView && horInView);\r\n    }\r\n    function isClickable(elem) {\r\n        return (isElementInViewport(elem) && elem.disabled !== true &&\r\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\r\n    }\r\n    // scroll to the element if it's not clickable\r\n    if (!isClickable(elem)) {\r\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\r\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\r\n        // if element is still not clickable take another scroll attempt\r\n        if (!isClickable(elem)) {\r\n            // scroll to element, try put it in the screen center.\r\n            // Should definitely work even if element was covered with sticky header/footer\r\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\r\n            return isClickable(elem);\r\n        }\r\n    }\r\n    return true;\r\n}).apply(null, arguments)",
  "args": [
    {
      "element-6066-11e4-a52e-4f735466cecf": "20d3f2fa-ebef-417a-89e5-fafd46e3c033",
      "ELEMENT": "20d3f2fa-ebef-417a-89e5-fafd46e3c033"
    }
  ]
}