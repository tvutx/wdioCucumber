{
  "script": "return (function isElementDisplayed(element) {\r\n    function nodeIsElement(node) {\r\n        if (!node) {\r\n            return false;\r\n        }\r\n        switch (node.nodeType) {\r\n            case Node.ELEMENT_NODE:\r\n            case Node.DOCUMENT_NODE:\r\n            case Node.DOCUMENT_FRAGMENT_NODE:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    function parentElementForElement(element) {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\r\n    }\r\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\r\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\r\n            if (predicate(node)) {\r\n                return node;\r\n            }\r\n        return null;\r\n    }\r\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\r\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\r\n            if (predicate(element)) {\r\n                return element;\r\n            }\r\n        return null;\r\n    }\r\n    function cascadedStylePropertyForElement(element, property) {\r\n        if (!element || !property) {\r\n            return null;\r\n        }\r\n        // if document-fragment, skip it and use element.host instead. This happens\r\n        // when the element is inside a shadow root.\r\n        // window.getComputedStyle errors on document-fragment.\r\n        if (element instanceof DocumentFragment) {\r\n            element = element.host;\r\n        }\r\n        let computedStyle = window.getComputedStyle(element);\r\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\r\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\r\n            return computedStyleProperty;\r\n        }\r\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\r\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\r\n        // Fall back to the first non-'inherit' value found in an ancestor.\r\n        // In any case, getPropertyValue will not return 'initial'.\r\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\r\n        // I think all important non-inheritable properties (width, height, etc.)\r\n        // for our purposes here are specially resolved, so this may not be an issue.\r\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\r\n        let parentElement = parentElementForElement(element);\r\n        return cascadedStylePropertyForElement(parentElement, property);\r\n    }\r\n    function elementSubtreeHasNonZeroDimensions(element) {\r\n        let boundingBox = element.getBoundingClientRect();\r\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\r\n            return true;\r\n        }\r\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\r\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\r\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\r\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\r\n        }\r\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\r\n        if (cascadedOverflow === 'hidden') {\r\n            return false;\r\n        }\r\n        // If the container's overflow is not hidden and it has zero size, consider the\r\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\r\n        return Array.from(element.childNodes).some((childNode) => {\r\n            if (childNode.nodeType === Node.TEXT_NODE) {\r\n                return true;\r\n            }\r\n            if (nodeIsElement(childNode)) {\r\n                return elementSubtreeHasNonZeroDimensions(childNode);\r\n            }\r\n            return false;\r\n        });\r\n    }\r\n    function elementOverflowsContainer(element) {\r\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\r\n        if (cascadedOverflow !== 'hidden') {\r\n            return false;\r\n        }\r\n        // FIXME: this needs to take into account the scroll position of the element,\r\n        // the display modes of it and its ancestors, and the container it overflows.\r\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\r\n        return true;\r\n    }\r\n    function isElementSubtreeHiddenByOverflow(element) {\r\n        if (!element) {\r\n            return false;\r\n        }\r\n        if (!elementOverflowsContainer(element)) {\r\n            return false;\r\n        }\r\n        if (!element.childNodes.length) {\r\n            return false;\r\n        }\r\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\r\n        return Array.from(element.childNodes).every((childNode) => {\r\n            // Returns true if the child node is overflowed or otherwise hidden.\r\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\r\n            // Visibility of text nodes is controlled by parent\r\n            if (childNode.nodeType === Node.TEXT_NODE) {\r\n                return false;\r\n            }\r\n            if (!nodeIsElement(childNode)) {\r\n                return true;\r\n            }\r\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\r\n                return true;\r\n            }\r\n            // Recurse.\r\n            return isElementSubtreeHiddenByOverflow(childNode);\r\n        });\r\n    }\r\n    // walk up the tree testing for a shadow root\r\n    function isElementInsideShadowRoot(element) {\r\n        if (!element) {\r\n            return false;\r\n        }\r\n        if (element.parentNode && element.parentNode.host) {\r\n            return true;\r\n        }\r\n        return isElementInsideShadowRoot(element.parentNode);\r\n    }\r\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\r\n    // When the W3C specification's algorithm stabilizes, we should implement that.\r\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\r\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\r\n        return false;\r\n    }\r\n    // Special cases for specific tag names.\r\n    switch (element.tagName.toUpperCase()) {\r\n        case 'BODY':\r\n            return true;\r\n        case 'SCRIPT':\r\n        case 'NOSCRIPT':\r\n            return false;\r\n        case 'OPTGROUP':\r\n        case 'OPTION': {\r\n            // Option/optgroup are considered shown if the containing <select> is shown.\r\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\r\n            return isElementDisplayed(enclosingSelectElement);\r\n        }\r\n        case 'INPUT':\r\n            // <input type=\"hidden\"> is considered not shown.\r\n            if (element.type === 'hidden') {\r\n                return false;\r\n            }\r\n            break;\r\n        // case 'MAP':\r\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\r\n        default:\r\n            break;\r\n    }\r\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\r\n        return false;\r\n    }\r\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\r\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\r\n    });\r\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\r\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\r\n    });\r\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\r\n        return false;\r\n    }\r\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\r\n        return false;\r\n    }\r\n    if (isElementSubtreeHiddenByOverflow(element)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}).apply(null, arguments)",
  "args": [
    {
      "element-6066-11e4-a52e-4f735466cecf": "4bd63513-53bc-4b0b-96a1-e1549bda23ce",
      "ELEMENT": "4bd63513-53bc-4b0b-96a1-e1549bda23ce"
    }
  ]
}